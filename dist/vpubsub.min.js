import{isFunction as e,uniqueId as n,isPlainObject as t}from"lodash-es";class s{constructor(){this._channels=Object.create(null)}static _getChannelEvent(e){const n=e.indexOf(".");return{channel:-1!==n?e.slice(0,n):"default",event:e.slice(n+1)}}_getEventQueue(e,n){n||({channel:e,event:n}=s._getChannelEvent(e));const t=this._channels[e]=this._channels[e]??Object.create(null),o=t[n]=t[n]??[];return{currentChannel:t,event:n,eventQueue:o}}trigger(e,...n){const{eventQueue:t,currentChannel:s}=this._getEventQueue(e),o=s["*"]??[],{eventQueue:r}=this._getEventQueue("*","*");for(const e of t)e.handler(...n);for(const t of o)t.handler(...n,e);for(const t of r)t.handler(...n,e)}request(n,...t){const{eventQueue:s,currentChannel:o}=this._getEventQueue(n),r=o["*"]??[],{eventQueue:u}=this._getEventQueue("*","*");return Promise.all(s.concat(r).concat(u).map((s=>{const o=s.handler(...t,n);return o&&e(o.then)?o:Promise.resolve(o)})))}on(t,s,o){const{eventQueue:r}=this._getEventQueue(t),u=n("vent-");if(!e(s))throw new Error(`Specified handler for channelEvent ${t} must be a function.`);return r.push({handler:s.bind(o||this),token:u}),u}once(e,n,t){const s=this.on(e,(()=>{this.off(e,s),n.apply(t||this,arguments)}))}off(e,n){const{currentChannel:t,event:s,eventQueue:o}=this._getEventQueue(e);t[s]=n?o.filter((e=>e.token!==n)):[]}}const o=new s;function r(n){return r.installed||(r.installed=!0,n.config.globalProperties.$vent=o,n.mixin({mounted(){const{vent:n}=this.$options;if(n&&t(n)){const t=new Map;for(const s of Object.keys(n)){const r=e(n[s])?n[s]:this[n[s]],u=o.on(s,r,this);t.set(s,u)}this._ventTokens=t}},beforeUnmount(){const{vent:e}=this.$options;if(e&&this._ventTokens){for(const[e,n]of this._ventTokens)o.off(e,n);delete this._ventTokens}}})),n}export{s as Vent,o as default,r as install,o as vent};
